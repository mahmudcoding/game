<!DOCTYPE html>
<html>
  <head>
    <title>Tower Defense Battle</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        background-color: #2c3e50;
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      #game-container {
        position: relative;
      }

      canvas {
        border: 3px solid #34495e;
        background-color: #95a5a6;
      }

      .ui-container {
        display: flex;
        justify-content: space-between;
        width: 1200px;
        margin-bottom: 10px;
      }

      .player-ui {
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        color: white;
        width: 250px;
      }

      .resource-info {
        margin-bottom: 10px;
        font-size: 14px;
      }

      .unit-buttons,
      .defense-buttons,
      .buff-buttons {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 5px;
        margin-bottom: 10px;
      }

      button {
        padding: 5px;
        background-color: #3498db;
        border: none;
        color: white;
        cursor: pointer;
        border-radius: 3px;
        font-size: 12px;
      }

      button:hover {
        background-color: #2980b9;
      }

      button:disabled {
        background-color: #7f8c8d;
        cursor: not-allowed;
      }

      #game-over {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.9);
        padding: 20px;
        border-radius: 10px;
        color: white;
        text-align: center;
      }

      #restart-button {
        padding: 10px 20px;
        font-size: 16px;
        margin-top: 10px;
      }
      #pause-button {
        position: absolute; /* Or relative, depending on your layout */
        top: 20px; /* Adjust position as needed */
        left: 20px; /* Adjust position as needed */
        padding: 10px 20px;
        background-color: #f39c12; /* Example color */
        border: none;
        color: white;
        cursor: pointer;
        border-radius: 5px;
        font-size: 16px;
        z-index: 10; /* Ensure it's above the canvas */
      }
      #pause-button:hover {
        background-color: #e67e22; /* Darker color on hover */
      }
    </style>
  </head>
  <body>
    <button id="pause-button" onclick="togglePause()">Pause</button>
    <div class="ui-container">
      <div class="player-ui" id="player1-ui">
        <div class="resource-info">
          <div>Gold: <span id="p1-gold">200</span></div>
          <div>Tower HP: <span id="p1-hp">1000</span></div>
        </div>
        <div class="unit-buttons">
          <button onclick="spawnUnit(0, 'swordsman')">Swordsman (50)</button>
          <button onclick="spawnUnit(0, 'bowman')">Bowman (60)</button>
          <button onclick="spawnUnit(0, 'cavalry')">Cavalry (80)</button>
          <button onclick="spawnUnit(0, 'arcubalist')">Arcubalist (70)</button>
        </div>
        <div class="defense-buttons">
          <button onclick="buildDefense(0, 'wood')">Wood Wall (30)</button>
          <button onclick="buildDefense(0, 'stone')">Stone Wall (50)</button>
          <button onclick="buildDefense(0, 'iron')">Iron Wall (80)</button>
          <button onclick="buildDefense(0, 'archer')">
            Archer Tower (100)
          </button>
        </div>
        <div class="buff-buttons">
          <button onclick="activateBuff(0, 'reinforce')">
            Reinforce (100)
          </button>
          <button onclick="activateBuff(0, 'poison')">Poison (120)</button>
          <button onclick="activateBuff(0, 'warcry')">War Cry (150)</button>
          <button onclick="activateBuff(0, 'heal')">Healing (130)</button>
        </div>
      </div>
      <div class="player-ui" id="player2-ui">
        <div class="resource-info">
          <div>Gold: <span id="p2-gold">200</span></div>
          <div>Tower HP: <span id="p2-hp">1000</span></div>
        </div>
        <!-- <div class="unit-buttons">
          <button onclick="spawnUnit(1, 'swordsman')">Swordsman (50)</button>
          <button onclick="spawnUnit(1, 'bowman')">Bowman (60)</button>
          <button onclick="spawnUnit(1, 'cavalry')">Cavalry (80)</button>
          <button onclick="spawnUnit(1, 'arcubalist')">Arcubalist (70)</button>
        </div>
        <div class="defense-buttons">
          <button onclick="buildDefense(1, 'wood')">Wood Wall (30)</button>
          <button onclick="buildDefense(1, 'stone')">Stone Wall (50)</button>
          <button onclick="buildDefense(1, 'iron')">Iron Wall (80)</button>
          <button onclick="buildDefense(1, 'archer')">
            Archer Tower (100)
          </button>
        </div>
        <div class="buff-buttons">
          <button onclick="activateBuff(1, 'reinforce')">
            Reinforce (100)
          </button>
          <button onclick="activateBuff(1, 'poison')">Poison (120)</button>
          <button onclick="activateBuff(1, 'warcry')">War Cry (150)</button>
          <button onclick="activateBuff(1, 'heal')">Healing (130)</button>
        </div> -->
      </div>
    </div>
    <div id="game-container">
      <canvas id="gameCanvas" width="1200" height="600"></canvas>
      <div id="game-over">
        <h2 id="winner-text"></h2>
        <button id="restart-button" onclick="restartGame()">Play Again</button>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const IMAGES = {
        // Organize images by type
        units: {
          swordsman: new Image(),
          bowman: new Image(),
          cavalry: new Image(),
          arcubalist: new Image(),
        },
        towers: {
          wood: new Image(),
          stone: new Image(),
          iron: new Image(),
          archer: new Image(),
        },
        mainTower: new Image(),
      };
      // Game constants
      const GAME_WIDTH = 1200;
      const GAME_HEIGHT = 600;
      const TOWER_WIDTH = 100;
      const TOWER_HEIGHT = 200;
      const UNIT_SIZE = 30;
      const WALL_WIDTH = 30;
      const WALL_HEIGHT = 80;
      const AI_ENABLED = true;
      const AI_DELAY = 1000;
      let gamePaused = true;

      function togglePause() {
        gamePaused = !gamePaused;
        const pauseButton = document.getElementById("pause-button");
        pauseButton.textContent = gamePaused ? "Resume" : "Pause"; // Change button text
        if (!gamePaused) {
          gameLoop(); // Restart game loop if resumed
        }
      }
      // Game state
      let gameState = {
        players: [
          {
            gold: 200,
            towerHP: 1000,
            units: [],
            defenses: [],
            buffs: {
              reinforce: false,
              poison: false,
              warcry: false,
              heal: false,
            },
          },
          {
            gold: 200,
            towerHP: 1000,
            units: [],
            defenses: [],
            buffs: {
              reinforce: false,
              poison: false,
              warcry: false,
              heal: false,
            },
          },
        ],
        projectiles: [],
      };

      // Unit configurations
      const UNITS = {
        swordsman: {
          cost: 50,
          hp: 320,
          damage: 20,
          speed: 2,
          range: 30,
          color: "#e74c3c",
        },
        bowman: {
          cost: 60,
          hp: 280,
          damage: 15,
          speed: 1.5,
          range: 150,
          color: "#27ae60",
        },
        cavalry: {
          cost: 80,
          hp: 330,
          damage: 25,
          speed: 3,
          range: 40,
          color: "#f1c40f",
        },
        arcubalist: {
          cost: 70,
          hp: 300,
          damage: 18,
          speed: 1.8,
          range: 200,
          color: "#9b59b6",
        },
      };

      // Defense configurations
      const DEFENSES = {
        wood: {
          cost: 30,
          hp: 200,
          color: "#795548",
        },
        stone: {
          cost: 50,
          hp: 400,
          color: "#95a5a6",
        },
        iron: {
          cost: 80,
          hp: 600,
          color: "#7f8c8d",
        },
        archer: {
          cost: 100,
          hp: 300,
          damage: 15,
          range: 200,
          color: "#2ecc71",
        },
      };

      // Buff configurations
      const BUFFS = {
        reinforce: {
          cost: 100,
          duration: 10000,
        },
        poison: {
          cost: 120,
          duration: 8000,
        },
        warcry: {
          cost: 150,
          duration: 6000,
        },
        heal: {
          cost: 130,
          duration: 12000,
        },
      };
      class Unit {
        constructor(player, type, x, y) {
          this.player = player;
          this.type = type;
          this.x = x;
          this.y = y;
          this.width = UNIT_SIZE;
          this.height = UNIT_SIZE;
          Object.assign(this, UNITS[type]);
          this.maxHP = this.hp;
          this.direction = player === 0 ? 1 : -1;
          this.attackCooldown = 0;
          this.poisoned = false;
          this.image = IMAGES.units[type];
          this.width = 64;
          this.height = 64;
        }

        update() {
          // Movement
          if (!this.findTarget()) {
            this.x += this.speed * this.direction;
          }

          // Attack cooldown
          if (this.attackCooldown > 0) {
            this.attackCooldown--;
          }

          // Poison effect
          if (this.poisoned) {
            if (Math.random() < 0.1) {
              this.hp -= 5;
            }
          }

          // Healing effect
          if (gameState.players[this.player].buffs.heal) {
            if (Math.random() < 0.1) {
              this.hp = Math.min(this.maxHP, this.hp + 5);
            }
          }
        }

        findTarget() {
          const enemyPlayer = this.player === 0 ? 1 : 0;

          // Check for enemy units
          for (let unit of gameState.players[enemyPlayer].units) {
            if (this.isInRange(unit)) {
              this.attack(unit);
              return true;
            }
          }

          // Check for enemy defenses
          for (let defense of gameState.players[enemyPlayer].defenses) {
            if (this.isInRange(defense)) {
              this.attack(defense);
              return true;
            }
          }

          // Check enemy tower
          const towerX = enemyPlayer === 0 ? 0 : GAME_WIDTH - TOWER_WIDTH;
          if (Math.abs(this.x - towerX) < this.range + TOWER_WIDTH) {
            this.attackTower(enemyPlayer);
            return true;
          }

          return false;
        }

        isInRange(target) {
          const distance = Math.abs(this.x - target.x);
          return distance < this.range + target.width;
        }

        attack(target) {
          if (this.attackCooldown <= 0) {
            let damage = this.damage;

            // Counter system - only apply if target is a Unit
            if (target instanceof Unit) {
              if (this.isCounter(target.type)) {
                damage *= 2;
              } else if (target.isCounter(this.type)) {
                damage *= 0.5;
              }
            }

            // War cry buff
            if (gameState.players[this.player].buffs.warcry) {
              damage *= 1.5;
            }

            target.hp -= damage;

            // Poison effect - only apply to units
            if (
              gameState.players[this.player].buffs.poison &&
              target instanceof Unit
            ) {
              target.poisoned = true;
            }

            this.attackCooldown = 30;

            // Create projectile effect
            if (this.type === "bowman" || this.type === "arcubalist") {
              gameState.projectiles.push(
                new Projectile(this.x, this.y, target.x, target.y, this.player)
              );
            }
          }
        }

        attackTower(enemyPlayer) {
          if (this.attackCooldown <= 0) {
            let damage = this.damage;
            if (gameState.players[this.player].buffs.warcry) {
              damage *= 1.5;
            }
            gameState.players[enemyPlayer].towerHP -= damage;
            this.attackCooldown = 30;
          }
        }

        isCounter(targetType) {
          const counters = {
            swordsman: "bowman",
            bowman: "cavalry",
            cavalry: "arcubalist",
            arcubalist: "swordsman",
          };
          return counters[this.type] === targetType;
        }

        draw() {
          // Draw unit
          if (this.image.complete) {
            ctx.drawImage(
              this.image,
              this.x - this.width / 2,
              this.y - this.height / 2,
              this.width,
              this.height
            );
          } else {
            ctx.fillStyle = this.color;
            ctx.fillRect(
              this.x - this.width / 2,
              this.y - this.height / 2,
              this.width,
              this.height
            );
          }

          // Draw health bar
          const healthPercent = this.hp / this.maxHP;
          ctx.fillStyle = "#e74c3c";
          ctx.fillRect(
            this.x - this.width / 2,
            this.y - this.height / 2 - 10,
            this.width,
            5
          );
          ctx.fillStyle = "#2ecc71";
          ctx.fillRect(
            this.x - this.width / 2,
            this.y - this.height / 2 - 10,
            this.width * healthPercent,
            5
          );
        }
      }

      // Defense class
      class Defense {
        constructor(player, type, x, y) {
          this.player = player;
          this.type = type;
          this.x = x;
          this.y = y;
          Object.assign(this, DEFENSES[type]);
          this.maxHP = this.hp;
          this.attackCooldown = 0;
          this.image = IMAGES.towers[type];
          this.width = 96;
          this.height = 96;
        }

        update() {
          if (this.type === "archer") {
            this.updateArcherTower();
          }
        }

        updateArcherTower() {
          if (this.attackCooldown > 0) {
            this.attackCooldown--;
            return;
          }

          const enemyPlayer = this.player === 0 ? 1 : 0;
          for (let unit of gameState.players[enemyPlayer].units) {
            if (this.isInRange(unit)) {
              this.attack(unit);
              break;
            }
          }
        }

        isInRange(target) {
          const distance = Math.abs(this.x - target.x);
          return distance < this.range + target.width;
        }

        attack(target) {
          if (this.attackCooldown <= 0) {
            let damage = this.damage;

            // War cry buff
            if (gameState.players[this.player].buffs.warcry) {
              damage *= 1.5;
            }

            target.hp -= damage;
            this.attackCooldown = 30;

            // Create projectile effect
            gameState.projectiles.push(
              new Projectile(this.x, this.y, target.x, target.y, this.player)
            );
          }
        }

        draw() {
          // Draw defense
          if (this.image.complete) {
            ctx.drawImage(
              this.image,
              this.x - this.width / 2,
              this.y - this.height / 2,
              this.width,
              this.height
            );
          } else {
            ctx.fillStyle = this.color; // Placeholder
            ctx.fillRect(
              this.x - this.width / 2,
              this.y - this.height / 2,
              this.width,
              this.height
            );
          }

          // Draw health bar
          const healthPercent = this.hp / this.maxHP;
          ctx.fillStyle = "#e74c3c";
          ctx.fillRect(
            this.x - this.width / 2,
            this.y - this.height / 2 - 10,
            this.width,
            5
          );
          ctx.fillStyle = "#2ecc71";
          ctx.fillRect(
            this.x - this.width / 2,
            this.y - this.height / 2 - 10,
            this.width * healthPercent,
            5
          );
        }
      }

      // Projectile class
      class Projectile {
        constructor(startX, startY, targetX, targetY, player) {
          this.x = startX;
          this.y = startY;
          this.targetX = targetX;
          this.targetY = targetY;
          this.player = player;
          this.speed = 10;
          this.color = player === 0 ? "#3498db" : "#e74c3c";
        }

        update() {
          const dx = this.targetX - this.x;
          const dy = this.targetY - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < this.speed) {
            this.x = this.targetX;
            this.y = this.targetY;
          } else {
            this.x += (dx / distance) * this.speed;
            this.y += (dy / distance) * this.speed;
          }
        }

        draw() {
          ctx.beginPath();
          ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
          ctx.closePath();
        }
      }

      function loadImages() {
        for (const type in IMAGES.units) {
          IMAGES.units[type].src = `./assets/${type}.png`;
          IMAGES.units[type].onerror = (error) => {
            console.error(`Error loading unit image ${type}:`, error);
          };
        }
        for (const type in IMAGES.towers) {
          IMAGES.towers[type].src = `assets/${type}.png`;
          IMAGES.towers[type].onerror = (error) => {
            console.error(`Error loading tower image ${type}:`, error);
          };
        }

        IMAGES.mainTower.src = "assets/maintower.png";
        IMAGES.mainTower.onerror = (error) => {
          console.error("Error loading main tower image:", error);
        };
        IMAGES.mainTower.onload = checkImagesLoaded;
      }

      // Initialize defenses at the start of the game
      function initializeDefenses() {
        // Player 1 defenses
        gameState.players[0].defenses.push(
          new Defense(0, "wood", 200, GAME_HEIGHT / 2)
        );
        gameState.players[0].defenses.push(
          new Defense(0, "archer", 400, GAME_HEIGHT / 2)
        );

        // Player 2 defenses
        gameState.players[1].defenses.push(
          new Defense(1, "wood", GAME_WIDTH - 200, GAME_HEIGHT / 2)
        );
        gameState.players[1].defenses.push(
          new Defense(1, "archer", GAME_WIDTH - 400, GAME_HEIGHT / 2)
        );
      }

      // Spawn unit function
      function spawnUnit(player, type) {
        const unitCost = UNITS[type].cost;
        if (gameState.players[player].gold >= unitCost) {
          const startX = player === 0 ? 100 : GAME_WIDTH - 100;
          const startY = GAME_HEIGHT / 2;
          gameState.players[player].units.push(
            new Unit(player, type, startX, startY)
          );
          gameState.players[player].gold -= unitCost;
          updateUI();
        }
      }

      // Build defense function
      function buildDefense(player, type) {
        const defenseCost = DEFENSES[type].cost;
        if (gameState.players[player].gold >= defenseCost) {
          const x = player === 0 ? 300 : GAME_WIDTH - 300;
          const y = GAME_HEIGHT / 2;
          gameState.players[player].defenses.push(
            new Defense(player, type, x, y)
          );
          gameState.players[player].gold -= defenseCost;
          updateUI();
        }
      }

      // Activate buff function
      function activateBuff(player, type) {
        const buffCost = BUFFS[type].cost;
        if (gameState.players[player].gold >= buffCost) {
          gameState.players[player].buffs[type] = true;
          gameState.players[player].gold -= buffCost;
          setTimeout(() => {
            gameState.players[player].buffs[type] = false;
          }, BUFFS[type].duration);
          updateUI();
        }
      }

      // Update UI function
      function updateUI() {
        document.getElementById("p1-gold").textContent =
          gameState.players[0].gold;
        document.getElementById("p1-hp").textContent =
          gameState.players[0].towerHP;
        document.getElementById("p2-gold").textContent =
          gameState.players[1].gold;
        document.getElementById("p2-hp").textContent =
          gameState.players[1].towerHP;
      }
      function cleanupEntities() {
        // Clean up dead units
        for (let player of gameState.players) {
          player.units = player.units.filter((unit) => unit.hp > 0);
          player.defenses = player.defenses.filter((defense) => defense.hp > 0);
        }

        // Clean up completed projectiles
        gameState.projectiles = gameState.projectiles.filter((projectile) => {
          return (
            projectile.x !== projectile.targetX ||
            projectile.y !== projectile.targetY
          );
        });
      }
      const GOLD_INTERVAL = 3000; // Generate gold every 5 seconds

      // Function to add gold for each player
      function generateGold() {
        for (let player of gameState.players) {
          player.gold += 10; // Adjust the amount of gold generated
        }
        updateUI();
      }

      // Set up gold generation timer
      setInterval(generateGold, GOLD_INTERVAL);
      loadImages(); // Load the images

      // Start the game loop only *after* the images have loaded (add this to the end of loadImages())
      let imagesLoadedCount = 0;
      const totalImages =
        Object.keys(IMAGES.units).length + Object.keys(IMAGES.towers).length;
      function checkImagesLoaded() {
        imagesLoadedCount++;
        if (imagesLoadedCount === totalImages) {
          initializeDefenses(); // Your existing initialization
          gameLoop(); // Start the game loop
        }
      }

      for (const type in IMAGES.units) {
        IMAGES.units[type].onload = checkImagesLoaded;
      }
      for (const type in IMAGES.towers) {
        IMAGES.towers[type].onload = checkImagesLoaded;
      }
      function aiPlay() {
        if (!AI_ENABLED) return;

        const aiPlayer = gameState.players[1];
        const humanPlayer = gameState.players[0];
        const enemyTowerHP = humanPlayer.towerHP;

        // 1. Prioritize Tower Attacks: If the human tower is vulnerable, focus on attacking it.
        const attackUnits = ["swordsman", "bowman", "cavalry", "arcubalist"];
        for (const unitType of attackUnits) {
          if (aiPlayer.gold >= UNITS[unitType].cost && enemyTowerHP < 500) {
            // Example threshold
            spawnUnit(1, unitType);
            return; // Stop after spawning one unit to allow other actions
          }
        }

        // 2. Balanced Unit Production: Create a mix of unit types.
        const unitChoices = ["swordsman", "bowman", "cavalry", "arcubalist"];
        const randomUnit =
          unitChoices[Math.floor(Math.random() * unitChoices.length)];
        if (aiPlayer.gold >= UNITS[randomUnit].cost) {
          spawnUnit(1, randomUnit);
          return;
        }

        // 3. Strategic Defenses: Build defenses to protect the tower.
        const defenseChoices = ["wood", "stone", "iron", "archer"];
        const randomDefense =
          defenseChoices[Math.floor(Math.random() * defenseChoices.length)];
        if (
          aiPlayer.gold >= DEFENSES[randomDefense].cost &&
          aiPlayer.defenses.length < 4
        ) {
          // Limit number of defenses
          buildDefense(1, randomDefense);
          return;
        }

        // 4. Timed Buff Usage: Use buffs strategically (e.g., before a major attack).
        const buffChoices = ["reinforce", "poison", "warcry", "heal"];
        const randomBuff =
          buffChoices[Math.floor(Math.random() * buffChoices.length)];
        if (
          aiPlayer.gold >= BUFFS[randomBuff].cost &&
          !aiPlayer.buffs[randomBuff]
        ) {
          // Don't use the same buff twice while active
          activateBuff(1, randomBuff);
          return;
        }
      }
      setInterval(aiPlay, AI_DELAY);
      // Game loop
      function gameLoop() {
        if (gamePaused) {
          return; // Do nothing if game is paused
        }
        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // Draw towers
        if (IMAGES.mainTower.complete) {
            ctx.drawImage(
              IMAGES.mainTower,
              GAME_WIDTH - 100,
              GAME_HEIGHT / 2 - 80,
              128,
              128
            );
          } else {
            // Placeholder (optional)
            ctx.fillStyle = "gray";
            ctx.fillRect(
              GAME_WIDTH - 100,
              GAME_HEIGHT / 2 - 150,
              128,
              128
            );
          }
          if (IMAGES.mainTower.complete) {
            ctx.drawImage(
              IMAGES.mainTower,
              0,
              GAME_HEIGHT / 2 - 80,
              128,
              128
            );
          } else {
            // Placeholder (optional)
            ctx.fillStyle = "gray";
            ctx.fillRect(
              GAME_WIDTH - 100,
              GAME_HEIGHT / 2 - 150,
              128,
              128
            );
          }
        cleanupEntities();
        // Update and draw units
        for (let player of gameState.players) {
          for (let unit of player.units) {
            unit.update();
            unit.draw();
          }
        }

        // Update and draw defenses
        for (let player of gameState.players) {
          for (let defense of player.defenses) {
            defense.update();
            defense.draw();
          }
        }

        // Update and draw projectiles
        for (let projectile of gameState.projectiles) {
          projectile.update();
          projectile.draw();
        }

        // Check for game over
        if (
          gameState.players[0].towerHP <= 0 ||
          gameState.players[1].towerHP <= 0
        ) {
          const winner =
            gameState.players[0].towerHP <= 0 ? "Player 2" : "Player 1";
          document.getElementById(
            "winner-text"
          ).textContent = `${winner} Wins!`;
          document.getElementById("game-over").style.display = "block";
          return;
        }

        requestAnimationFrame(gameLoop);
      }

      // Restart game function
      function restartGame() {
        gameState = {
          players: [
            {
              gold: 200,
              towerHP: 1000,
              units: [],
              defenses: [],
              buffs: {
                reinforce: false,
                poison: false,
                warcry: false,
                heal: false,
              },
            },
            {
              gold: 200,
              towerHP: 1000,
              units: [],
              defenses: [],
              buffs: {
                reinforce: false,
                poison: false,
                warcry: false,
                heal: false,
              },
            },
          ],
          projectiles: [],
        };
        initializeDefenses();
        updateUI();
        document.getElementById("game-over").style.display = "none";
        gamePaused = true;
        document.getElementById("pause-button").textContent = "Pause";
        gameLoop();
      }

      // Start the game
      initializeDefenses();
      gameLoop();
    </script>
  </body>
</html>

